<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>EleNa.src.app.data_model.data_model API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EleNa.src.app.data_model.data_model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import osmnx as ox
import pickle as pickle
import json


class DataModel:
    &#34;&#34;&#34;
    Data Model part of Tech Stack to store spatial geo data in graph structure (adjacency lists)
    Use OSMNX services to get graph as per location. Use Google Maps API to fetch elevation information
    &#34;&#34;&#34;
    def __init__(self, city_name=&#39;Amherst, MA&#39;):
        &#34;&#34;&#34;
        Initialize Data Model
        Args:
            city_name: string with city name, state name.
            If pre-built data model exists, load it. Else create and dump it
        &#34;&#34;&#34;
        self.config, self.loaded_graphs, self.G = {}, {}, {}
        self.load_config(&#39;./app/config.json&#39;)
        self.graphs_location = self.config.get(&#39;app&#39;)[&#39;graphs_location&#39;]
        self.load_locations_metadata()

        if city_name in self.loaded_graphs:
            self.load_graph_from_path(self.loaded_graphs[city_name])
            print(&#39;Loaded graph for {} from dump&#39;.format(city_name))
        else:
            pickle_path = self.graphs_location + str(abs(hash(city_name))) + &#39;.pickle&#39;
            self.loaded_graphs[city_name] = pickle_path
            self.G = ox.graph_from_place(city_name)
            self.add_elevation_to_graph()
            self.dump_graph_pickle(pickle_path)
            self.update_locations_metadata()
            print(&#39;Loaded graph for {} and added to dump&#39;.format(city_name))

    def load_config(self, loc):
        &#34;&#34;&#34;
        Load config corresponding to directory paths and API keys
        Args:
            loc: path to config file

        Returns: None
        &#34;&#34;&#34;
        try:
            cfg_file = open(loc, &#34;r&#34;)
            self.config = json.load(cfg_file)
        except OSError as err:
            print(&#34;Config File Read Error: {0}&#34;.format(err))
        else:
            cfg_file.close()

    def load_locations_metadata(self):
        &#34;&#34;&#34;
        Load pre-built graphs from local directory path
        Returns: None
        &#34;&#34;&#34;
        with open(self.graphs_location + &#39;metadata.json&#39;) as f:
            self.loaded_graphs = json.load(f)

    def update_locations_metadata(self):
        &#34;&#34;&#34;
        Update json with loaded_graphs information
        Returns: None

        &#34;&#34;&#34;
        with open(self.graphs_location + &#39;metadata.json&#39;, &#34;w&#34;) as outfile:
            json.dump(self.loaded_graphs, outfile, indent=4)

    def plot_graph(self):
        &#34;&#34;&#34;
        Plot graph using OSMNX
        Returns: None
        &#34;&#34;&#34;
        ox.plot_graph(self.G)

    def dump_graph_pickle(self, pickle_path):
        &#34;&#34;&#34;
        Args:
            pickle_path: local path to dump data model graph

        Returns: None
        &#34;&#34;&#34;
        pickle.dump(self.G, open(pickle_path, &#39;wb&#39;))

    def load_graph_from_path(self, pickle_path):
        &#34;&#34;&#34;
        Args:
            pickle_path: path in the directory to load pre-built graph

        Returns: data model (graph)
        &#34;&#34;&#34;
        self.G = pickle.load(open(pickle_path, &#39;rb&#39;))

    def get_stats(self):
        &#34;&#34;&#34;
        Returns: statistics corresponding to the graph, i.e number of nodes &amp; edges
        &#34;&#34;&#34;
        num_nodes = self.G.number_of_nodes()
        num_edges = self.G.number_of_edges()
        return num_nodes, num_edges

    def get_adjacency_for_node(self, node_id):
        &#34;&#34;&#34;
        Args:
            node_id: node for which connections are required

        Returns: adjacency list for the node corresponding to node_id
        &#34;&#34;&#34;
        for i in self.G.adjacency():
            if i[0] == node_id:
                print(i)

    def get_graph(self):
        &#34;&#34;&#34;
        Returns: graph to be used in shortest path algorithm
        &#34;&#34;&#34;
        return self.G

    def add_elevation_to_graph(self):
        &#34;&#34;&#34;
        Use google maps API to add elevation to the graph
        Returns: None
        &#34;&#34;&#34;
        api_prop = self.config.get(&#39;google_api&#39;)
        if len(api_prop.keys()) == 0 or &#39;api_key&#39; not in api_prop:
            print(&#34;Config File Error&#34;)
            raise ValueError
        ox.elevation.add_node_elevations(self.G, api_prop[&#39;api_key&#39;],
                                         max_locations_per_batch=api_prop[&#39;elevation_api&#39;][
                                             &#39;batch_size&#39;],
                                         precision=api_prop[&#39;elevation_api&#39;][&#39;precision&#39;])
        ox.elevation.add_edge_grades(self.G, add_absolute=api_prop[&#39;elevation_api&#39;][&#39;add_absolute&#39;])
        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="EleNa.src.app.data_model.data_model.DataModel"><code class="flex name class">
<span>class <span class="ident">DataModel</span></span>
<span>(</span><span>city_name='Amherst, MA')</span>
</code></dt>
<dd>
<div class="desc"><p>Data Model part of Tech Stack to store spatial geo data in graph structure (adjacency lists)
Use OSMNX services to get graph as per location. Use Google Maps API to fetch elevation information</p>
<p>Initialize Data Model</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>city_name</code></strong></dt>
<dd>string with city name, state name.</dd>
</dl>
<p>If pre-built data model exists, load it. Else create and dump it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataModel:
    &#34;&#34;&#34;
    Data Model part of Tech Stack to store spatial geo data in graph structure (adjacency lists)
    Use OSMNX services to get graph as per location. Use Google Maps API to fetch elevation information
    &#34;&#34;&#34;
    def __init__(self, city_name=&#39;Amherst, MA&#39;):
        &#34;&#34;&#34;
        Initialize Data Model
        Args:
            city_name: string with city name, state name.
            If pre-built data model exists, load it. Else create and dump it
        &#34;&#34;&#34;
        self.config, self.loaded_graphs, self.G = {}, {}, {}
        self.load_config(&#39;./app/config.json&#39;)
        self.graphs_location = self.config.get(&#39;app&#39;)[&#39;graphs_location&#39;]
        self.load_locations_metadata()

        if city_name in self.loaded_graphs:
            self.load_graph_from_path(self.loaded_graphs[city_name])
            print(&#39;Loaded graph for {} from dump&#39;.format(city_name))
        else:
            pickle_path = self.graphs_location + str(abs(hash(city_name))) + &#39;.pickle&#39;
            self.loaded_graphs[city_name] = pickle_path
            self.G = ox.graph_from_place(city_name)
            self.add_elevation_to_graph()
            self.dump_graph_pickle(pickle_path)
            self.update_locations_metadata()
            print(&#39;Loaded graph for {} and added to dump&#39;.format(city_name))

    def load_config(self, loc):
        &#34;&#34;&#34;
        Load config corresponding to directory paths and API keys
        Args:
            loc: path to config file

        Returns: None
        &#34;&#34;&#34;
        try:
            cfg_file = open(loc, &#34;r&#34;)
            self.config = json.load(cfg_file)
        except OSError as err:
            print(&#34;Config File Read Error: {0}&#34;.format(err))
        else:
            cfg_file.close()

    def load_locations_metadata(self):
        &#34;&#34;&#34;
        Load pre-built graphs from local directory path
        Returns: None
        &#34;&#34;&#34;
        with open(self.graphs_location + &#39;metadata.json&#39;) as f:
            self.loaded_graphs = json.load(f)

    def update_locations_metadata(self):
        &#34;&#34;&#34;
        Update json with loaded_graphs information
        Returns: None

        &#34;&#34;&#34;
        with open(self.graphs_location + &#39;metadata.json&#39;, &#34;w&#34;) as outfile:
            json.dump(self.loaded_graphs, outfile, indent=4)

    def plot_graph(self):
        &#34;&#34;&#34;
        Plot graph using OSMNX
        Returns: None
        &#34;&#34;&#34;
        ox.plot_graph(self.G)

    def dump_graph_pickle(self, pickle_path):
        &#34;&#34;&#34;
        Args:
            pickle_path: local path to dump data model graph

        Returns: None
        &#34;&#34;&#34;
        pickle.dump(self.G, open(pickle_path, &#39;wb&#39;))

    def load_graph_from_path(self, pickle_path):
        &#34;&#34;&#34;
        Args:
            pickle_path: path in the directory to load pre-built graph

        Returns: data model (graph)
        &#34;&#34;&#34;
        self.G = pickle.load(open(pickle_path, &#39;rb&#39;))

    def get_stats(self):
        &#34;&#34;&#34;
        Returns: statistics corresponding to the graph, i.e number of nodes &amp; edges
        &#34;&#34;&#34;
        num_nodes = self.G.number_of_nodes()
        num_edges = self.G.number_of_edges()
        return num_nodes, num_edges

    def get_adjacency_for_node(self, node_id):
        &#34;&#34;&#34;
        Args:
            node_id: node for which connections are required

        Returns: adjacency list for the node corresponding to node_id
        &#34;&#34;&#34;
        for i in self.G.adjacency():
            if i[0] == node_id:
                print(i)

    def get_graph(self):
        &#34;&#34;&#34;
        Returns: graph to be used in shortest path algorithm
        &#34;&#34;&#34;
        return self.G

    def add_elevation_to_graph(self):
        &#34;&#34;&#34;
        Use google maps API to add elevation to the graph
        Returns: None
        &#34;&#34;&#34;
        api_prop = self.config.get(&#39;google_api&#39;)
        if len(api_prop.keys()) == 0 or &#39;api_key&#39; not in api_prop:
            print(&#34;Config File Error&#34;)
            raise ValueError
        ox.elevation.add_node_elevations(self.G, api_prop[&#39;api_key&#39;],
                                         max_locations_per_batch=api_prop[&#39;elevation_api&#39;][
                                             &#39;batch_size&#39;],
                                         precision=api_prop[&#39;elevation_api&#39;][&#39;precision&#39;])
        ox.elevation.add_edge_grades(self.G, add_absolute=api_prop[&#39;elevation_api&#39;][&#39;add_absolute&#39;])
        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EleNa.src.app.data_model.data_model.DataModel.add_elevation_to_graph"><code class="name flex">
<span>def <span class="ident">add_elevation_to_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Use google maps API to add elevation to the graph
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_elevation_to_graph(self):
    &#34;&#34;&#34;
    Use google maps API to add elevation to the graph
    Returns: None
    &#34;&#34;&#34;
    api_prop = self.config.get(&#39;google_api&#39;)
    if len(api_prop.keys()) == 0 or &#39;api_key&#39; not in api_prop:
        print(&#34;Config File Error&#34;)
        raise ValueError
    ox.elevation.add_node_elevations(self.G, api_prop[&#39;api_key&#39;],
                                     max_locations_per_batch=api_prop[&#39;elevation_api&#39;][
                                         &#39;batch_size&#39;],
                                     precision=api_prop[&#39;elevation_api&#39;][&#39;precision&#39;])
    ox.elevation.add_edge_grades(self.G, add_absolute=api_prop[&#39;elevation_api&#39;][&#39;add_absolute&#39;])
    return</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.dump_graph_pickle"><code class="name flex">
<span>def <span class="ident">dump_graph_pickle</span></span>(<span>self, pickle_path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>pickle_path</code></strong></dt>
<dd>local path to dump data model graph</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_graph_pickle(self, pickle_path):
    &#34;&#34;&#34;
    Args:
        pickle_path: local path to dump data model graph

    Returns: None
    &#34;&#34;&#34;
    pickle.dump(self.G, open(pickle_path, &#39;wb&#39;))</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.get_adjacency_for_node"><code class="name flex">
<span>def <span class="ident">get_adjacency_for_node</span></span>(<span>self, node_id)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>node for which connections are required</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>adjacency list for the node corresponding to node_id</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_adjacency_for_node(self, node_id):
    &#34;&#34;&#34;
    Args:
        node_id: node for which connections are required

    Returns: adjacency list for the node corresponding to node_id
    &#34;&#34;&#34;
    for i in self.G.adjacency():
        if i[0] == node_id:
            print(i)</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: graph to be used in shortest path algorithm</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_graph(self):
    &#34;&#34;&#34;
    Returns: graph to be used in shortest path algorithm
    &#34;&#34;&#34;
    return self.G</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.get_stats"><code class="name flex">
<span>def <span class="ident">get_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: statistics corresponding to the graph, i.e number of nodes &amp; edges</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats(self):
    &#34;&#34;&#34;
    Returns: statistics corresponding to the graph, i.e number of nodes &amp; edges
    &#34;&#34;&#34;
    num_nodes = self.G.number_of_nodes()
    num_edges = self.G.number_of_edges()
    return num_nodes, num_edges</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>self, loc)</span>
</code></dt>
<dd>
<div class="desc"><p>Load config corresponding to directory paths and API keys</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loc</code></strong></dt>
<dd>path to config file</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(self, loc):
    &#34;&#34;&#34;
    Load config corresponding to directory paths and API keys
    Args:
        loc: path to config file

    Returns: None
    &#34;&#34;&#34;
    try:
        cfg_file = open(loc, &#34;r&#34;)
        self.config = json.load(cfg_file)
    except OSError as err:
        print(&#34;Config File Read Error: {0}&#34;.format(err))
    else:
        cfg_file.close()</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.load_graph_from_path"><code class="name flex">
<span>def <span class="ident">load_graph_from_path</span></span>(<span>self, pickle_path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>pickle_path</code></strong></dt>
<dd>path in the directory to load pre-built graph</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>data model (graph)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_graph_from_path(self, pickle_path):
    &#34;&#34;&#34;
    Args:
        pickle_path: path in the directory to load pre-built graph

    Returns: data model (graph)
    &#34;&#34;&#34;
    self.G = pickle.load(open(pickle_path, &#39;rb&#39;))</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.load_locations_metadata"><code class="name flex">
<span>def <span class="ident">load_locations_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load pre-built graphs from local directory path
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_locations_metadata(self):
    &#34;&#34;&#34;
    Load pre-built graphs from local directory path
    Returns: None
    &#34;&#34;&#34;
    with open(self.graphs_location + &#39;metadata.json&#39;) as f:
        self.loaded_graphs = json.load(f)</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot graph using OSMNX
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(self):
    &#34;&#34;&#34;
    Plot graph using OSMNX
    Returns: None
    &#34;&#34;&#34;
    ox.plot_graph(self.G)</code></pre>
</details>
</dd>
<dt id="EleNa.src.app.data_model.data_model.DataModel.update_locations_metadata"><code class="name flex">
<span>def <span class="ident">update_locations_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update json with loaded_graphs information
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_locations_metadata(self):
    &#34;&#34;&#34;
    Update json with loaded_graphs information
    Returns: None

    &#34;&#34;&#34;
    with open(self.graphs_location + &#39;metadata.json&#39;, &#34;w&#34;) as outfile:
        json.dump(self.loaded_graphs, outfile, indent=4)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EleNa.src.app.data_model" href="index.html">EleNa.src.app.data_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="EleNa.src.app.data_model.data_model.DataModel" href="#EleNa.src.app.data_model.data_model.DataModel">DataModel</a></code></h4>
<ul class="">
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.add_elevation_to_graph" href="#EleNa.src.app.data_model.data_model.DataModel.add_elevation_to_graph">add_elevation_to_graph</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.dump_graph_pickle" href="#EleNa.src.app.data_model.data_model.DataModel.dump_graph_pickle">dump_graph_pickle</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.get_adjacency_for_node" href="#EleNa.src.app.data_model.data_model.DataModel.get_adjacency_for_node">get_adjacency_for_node</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.get_graph" href="#EleNa.src.app.data_model.data_model.DataModel.get_graph">get_graph</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.get_stats" href="#EleNa.src.app.data_model.data_model.DataModel.get_stats">get_stats</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.load_config" href="#EleNa.src.app.data_model.data_model.DataModel.load_config">load_config</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.load_graph_from_path" href="#EleNa.src.app.data_model.data_model.DataModel.load_graph_from_path">load_graph_from_path</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.load_locations_metadata" href="#EleNa.src.app.data_model.data_model.DataModel.load_locations_metadata">load_locations_metadata</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.plot_graph" href="#EleNa.src.app.data_model.data_model.DataModel.plot_graph">plot_graph</a></code></li>
<li><code><a title="EleNa.src.app.data_model.data_model.DataModel.update_locations_metadata" href="#EleNa.src.app.data_model.data_model.DataModel.update_locations_metadata">update_locations_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>